
********************  COMMON COMMANDS  ********************


Check the update log:    sudo tail -n 100 /var/log/xmrig_update.log

Check a miner on windows:   echo jjasfSGB123 | ncat 192.168.1.35 8080
    Powershell install ncat command:   winget install Nmap

Get miner status:   source /etc/miner.env && printf '%s\r\n' "$STATUS_TOKEN" | nc -w 2 127.0.0.1 "$STATUS_PORT"





********************  INSTALL SENSORS   ********************

Command:   sudo apt update
Command:   sudo apt install lm-sensors -y
Command:   yes | sudo sensors-detect --auto

Read Temps and Voltages:    sensors










miner-status-handler.sh is a secure, fault-tolerant telemetry script that runs each time a client connects to the miner’s status port, verifies the provided password, loads configuration from /etc/miner.env, and then collects real-time hashrate, CPU temperature, and wattage using several layered fallback methods to ensure compatibility across different XMRig versions and hardware. It intelligently probes multiple API endpoints to extract the 10-second hashrate, reads temperature from lm-sensors or system thermal files, determines power either from AMD PPT, generic sensor keys, a configured fallback value, or by calculating VRM current × voltage when necessary. Every step is logged to /var/log/miner-status.log, and regardless of errors, the script always returns a clean, machine-readable JSON object containing the miner’s current performance metrics, making it reliable for dashboards, automation tools, and your auto-update system.







********************   MINER STATUS   ********************

Command:   sudo nano /usr/local/bin/miner-status-handler.sh
#########################################################
#!/usr/bin/env bash
# Per-connection handler for miner-status
set -euo pipefail

# ----- safety: PASSWORD must be exported by the listener -----
if [ -z "${PASSWORD:-}" ]; then
  printf '%s\r\n' '{"error":"server password not set"}'
  exit 0
fi

# ----- Load runtime configuration (prefer /etc/miner.env) -----
[ -f /etc/miner.env ] && . /etc/miner.env
: "${API_HOST:=127.0.0.1}"
: "${API_PORT:=${XMRIG_HTTP_PORT:-8086}}"    # XMRig HTTP API port
: "${API_TOKEN:=${XMRIG_HTTP_TOKEN:-}}"      # XMRig HTTP token
: "${LOG:=/var/log/miner-status.log}"

log() { printf '%s %s\n' "$(date '+%F %T')" "$*" >>"$LOG"; }

# ----- helpers ----------------------------------------------------------

# Read hashrate (10s) from XMRig HTTP API; returns plain integer (no commas)
read_hashrate() {
  local json h10 try_port curl_rc
  log "DEBUG: read_hashrate() starting (API_HOST=${API_HOST:-127.0.0.1}, API_PORT=${API_PORT:-8086}, API_TOKEN=${API_TOKEN:-none})"

  # ----- build curl args -----
  local curl_args=(-fsS --max-time 3)
  if [ -n "${API_TOKEN:-}" ]; then
    curl_args+=(-H "Authorization: Bearer $API_TOKEN")
  fi
  log "DEBUG: curl args built: ${curl_args[*]}"

  # ----- ports and paths to try -----
  local ports=()
  if [ -n "${API_PORT:-}" ]; then ports+=("$API_PORT"); fi
  ports+=("8086" "8080")   # fallback ports
  local paths=(/2/summary /1/summary /summary)

  for try_port in "${ports[@]}"; do
    for path in "${paths[@]}"; do
      log "DEBUG: Trying endpoint http://${API_HOST:-127.0.0.1}:$try_port$path"
      json=$(curl "${curl_args[@]}" "http://${API_HOST:-127.0.0.1}:$try_port$path" 2>>"$LOG"); curl_rc=$?

      if [ $curl_rc -ne 0 ]; then
        log "DEBUG: curl failed (rc=$curl_rc) for http://${API_HOST:-127.0.0.1}:$try_port$path"
        continue
      fi
      if [ -z "$json" ]; then
        log "DEBUG: empty JSON from $path on port $try_port"
        continue
      fi

      log "DEBUG: first 200B of response: $(printf '%s' "$json" | head -c 200)"

      # Parse possible JSON shapes
      h10=$(
        printf '%s' "$json" | jq -r '
          if .hashrate? then
            if (.hashrate|type)=="object" then
              (.hashrate.total[0] // .hashrate.total_10s // .hashrate["10s"] // empty)
            elif (.hashrate|type)=="array" then
              .hashrate[0]
            else empty end
          elif .workers? then
            ([.workers[]
              | (if .hashrate? and (.hashrate|type)=="object" then .hashrate.total[0]
                 elif .hashrate? and (.hashrate|type)=="array" then .hashrate[0]
                 else empty end)
            ] | add)
          else empty end
        ' | awk 'NF { printf "%.0f", $1 }'
      )

      log "DEBUG: jq parsed h10='$h10' from $path:$try_port"

      if [ -n "$h10" ] && [[ "$h10" =~ ^[0-9]+$ ]]; then
        log "DEBUG: valid integer hashrate found: $h10"
        echo "$h10"
        return 0
      fi

      log "DEBUG: no valid integer hashrate found in $path on port $try_port"
    done
  done

  log "DEBUG: all endpoints tried, no valid hashrate found"
  return 1
}


# Read CPU temperature (Celsius integer)
read_cpu_temp() {
  local line val
  if command -v sensors >/dev/null 2>&1; then
    line=$(sensors 2>/dev/null | grep -m1 -E 'Tctl:|Tdie:|Package id 0:|CPU Temperature:') || true
    if [ -n "$line" ]; then
      val=$(echo "$line" | grep -oE '[0-9]+(\.[0-9]+)?' | head -n1)
      if [ -n "$val" ]; then
        printf '%s' "${val%.*}"
        return 0
      fi
    fi
  fi
  if [ -r /sys/class/thermal/thermal_zone0/temp ]; then
    awk '{printf "%d", int($1/1000)}' /sys/class/thermal/thermal_zone0/temp
    return 0
  fi
  return 1
}

# Read package/GPU power (Watts, integer) via lm-sensors
read_watts() {
  local line val

  # Ensure lm-sensors is available (quiet install like the other helpers)
  if ! command -v sensors >/dev/null 2>&1; then
    log "DEBUG: sensors missing — attempting install"
    apt-get update -y >>"$LOG" 2>&1 || true
    apt-get install -y lm-sensors >>"$LOG" 2>&1 || true
  fi

  if command -v sensors >/dev/null 2>&1; then
    # Prefer AMD PPT (your sample shows this), else try common power keys
    line=$(sensors 2>/dev/null | grep -m1 -E '^[[:space:]]*PPT:|^[[:space:]]*Package power:|^[[:space:]]*power1:')
    if [ -n "$line" ]; then
      # Extract first numeric value and floor to integer
      val=$(printf '%s' "$line" | grep -oE '[0-9]+(\.[0-9]+)?' | head -n1)
      if [ -n "$val" ]; then
        printf '%s' "${val%.*}"
        return 0
      fi
    fi
  fi

  # Final fallback: use env default if provided
  if [ -n "${WATTS:-}" ]; then
    printf '%s' "${WATTS}"
    return 0
  fi

  return 1
}

# Fallback: Calculate CPU power from VRM current × core voltage (for Miner2)
read_watts_fallback() {
  local current voltage watts
  if ! command -v sensors >/dev/null 2>&1; then
    return 1
  fi

  current=$(sensors 2>/dev/null | grep -m1 "CPU VRM Output Current:" | grep -oE '[0-9]+(\.[0-9]+)?' | head -n1)
  voltage=$(sensors 2>/dev/null | grep -m1 "CPU Core Voltage:" | grep -oE '[0-9]+(\.[0-9]+)?' | head -n1)

  if [[ -z "$current" || -z "$voltage" ]]; then
    return 1
  fi

  # Multiply and round down to integer
  watts=$(awk "BEGIN {printf \"%d\", $current * $voltage}")
  printf '%s' "$watts"
  return 0
}

# ----- auth + response (robust) -----
pass=""
if ! IFS= read -r -t 3 pass; then
  log "WARN: password read failed or timed out"
else
  pass=${pass%$'\r'}
fi

if [ -z "${pass}" ] || [ "$pass" != "$PASSWORD" ]; then
  printf '%s\r\n' '{"error":"invalid or missing password"}'
  exit 0
fi

# ----- get metrics safely (no echo fallbacks) -----
HR=0
if output=$(read_hashrate 2>/dev/null) && [[ "$output" =~ ^[0-9]+$ ]]; then
  HR="$output"
fi

TC=0
if output=$(read_cpu_temp 2>/dev/null) && [[ "$output" =~ ^[0-9]+$ ]]; then
  TC="$output"
fi

WT="${WATTS:-0}"
if output=$(read_watts 2>/dev/null) && [[ "$output" =~ ^[0-9]+$ ]] && [ "$output" -gt 0 ]; then
  WT="$output"
else
  if output=$(read_watts_fallback 2>/dev/null) && [[ "$output" =~ ^[0-9]+$ ]] && [ "$output" -gt 0 ]; then
    WT="$output"
    log "INFO: Used fallback VRM current × voltage for watts: $WT"
  fi
fi

log "RESULT: hashrate=$HR temp=$TC watts=$WT"
printf '{"hashrate":%s,"temp":%s,"watts":%s}\r\n' "$HR" "$TC" "$WT"
#########################################################
Ctrl-O, Enter, Ctrl-X



Command:   sudo chmod +x /usr/local/bin/miner-status-handler.sh





Command:   sudo nano /usr/local/bin/miner-status.sh
#########################################################
#!/usr/bin/env bash
# miner-status.sh — tiny TCP JSON server (socat-based)
set -euo pipefail
[ -f /etc/miner.env ] && . /etc/miner.env  

# Only export the TCP server password; handler loads the rest from /etc/miner.env
export PASSWORD="${STATUS_TOKEN}"   # from /etc/miner.env
PORT="${STATUS_PORT}"                 # from /etc/miner.env

echo "miner-status listening on :$PORT (password required)" >&2

# -T 5: I/O timeout; fork: one process per client; -d -d -v: verbose logs
exec socat -d -d -v -T 5 \
  TCP-LISTEN:"$PORT",reuseaddr,fork \
  EXEC:'/usr/local/bin/miner-status-handler.sh',stderr
#########################################################
Ctrl-O, Enter, Ctrl-X



Command:   sudo chmod +x /usr/local/bin/miner-status.sh

Command:   sudo chmod 755 /usr/local/bin/miner-status.sh

Command:   sudo apt update
Command:   sudo apt install -y socat netcat-openbsd
Command:   sudo apt install -y curl


Command:   sudo nano /etc/systemd/system/miner-status.service
#########################################################
[Unit]
Description=Miner Status JSON Server
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/local/bin/miner-status.sh
Restart=always
RestartSec=2
User=root
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
#########################################################
Ctrl-O Enter Ctrl-X




Command:   sudo chmod 644 /etc/systemd/system/miner-status.service

Command:   sudo systemctl daemon-reload
Command:   sudo systemctl enable --now miner-status.service
  

Command:   sudo reboot

Test the script on the same machine:   source /etc/miner.env && printf '%s\r\n' "$STATUS_TOKEN" | nc -w 2 127.0.0.1 "$STATUS_PORT"

If it doesn't work:   sudo journalctl -u miner-status -f
If it still doesn't work, run all the steps above on this page again.
If it still doesn't work, give the source and log to AI:   sudo tail -f /var/log/miner-status.log  

Correct Result:    {"hashrate":17245,"temp":70,"watts":101}


Powershell test the script on windows:   echo jjasfSGB122$@ | ncat 192.168.1.35 8080
    Powershell install ncat command:   winget install Nmap
   














This XMRig auto-update script is a fully automated maintenance system that checks GitHub for the newest XMRig release, compares it to the miner’s local version, gathers real-time performance metrics, identifies motherboard firmware, and then—if an update is available—stops the miner, pulls the latest tag, rebuilds XMRig from source, validates the build, restarts the service, and measures post-update hashrate, temperature, and wattage. Whether or not XMRig itself updates, the script also performs a complete Debian system upgrade, sends a detailed email report (with performance before/after, firmware info, and the latest 200 log lines), delays emails based on hostname to prevent inbox flooding, and finally reboots the system to apply updates. All actions are logged to /var/log/xmrig_update.log, and the script uses your miner-status TCP server to reliably fetch live metrics, making each miner self-updating, self-monitoring, and fully autonomous.






********************  XMRIG AUTO UPDATE   ********************

Command:   sudo nano /usr/local/bin/xmrig-auto-update.sh
#########################################################
#!/bin/bash
#Version 1.0
# XMRig auto-update (root)
# Logs: /var/log/xmrig_update.log
# Uses: /usr/local/bin/send_email.sh (provides send_email(subject, body))

set -o pipefail

REPO_DIR="/root/xmrig"
BUILD_DIR="$REPO_DIR/build"
BIN="$BUILD_DIR/xmrig"
LOG="/var/log/xmrig_update.log"
GITHUB_API="https://api.github.com/repos/xmrig/xmrig/releases/latest"

HOSTNAME_STR="$(hostname)"
[ -f /etc/miner.env ] && . /etc/miner.env

# ---- miner-status TCP JSON server (your socat listener) ----------------------
MINER_HOST="127.0.0.1"
MINER_PORT="${STATUS_PORT}"      # from /etc/miner.env
MINER_PASS="${STATUS_TOKEN}"     # from /etc/miner.env

# --- Load reusable email function --------------------------------------------
SEND_EMAIL_LIB="/usr/local/bin/send_email.sh"
if [ -r "$SEND_EMAIL_LIB" ]; then
  # shellcheck source=/usr/local/bin/send_email.sh
  source "$SEND_EMAIL_LIB"
else
  send_email() { echo "[WARN] send_email.sh not found; would have sent: $1"; }
fi

ts() { date '+%Y-%m-%d %H:%M:%S'; }
log() {
  local line="[$(ts)] $*"
  if [ -w "$LOG" ] || touch "$LOG" 2>/dev/null; then
    echo "$line" | tee -a "$LOG"
  else
    echo "$line"
  fi
}

# Delay emails by (hostname number × 30s); no delay if no number
host_email_delay() {
  local n d
  n="$(echo "$HOSTNAME_STR" | grep -oE '[0-9]+' | head -n1)"
  if [ -n "$n" ]; then
    d=$(( n * 30 ))
    log "Email delay: ${d}s (hostname number ${n})"
    sleep "$d"
  fi
}

# ---- Get Motherboard Firmware (BIOS/UEFI) ------------------------------------
get_motherboard_firmware() {
  local firmware="Unknown" raw_name="Unknown" manufacturer="Unknown" display_name="Unknown"

  # ── Ensure dmidecode exists and run as root ──
  if ! command -v dmidecode >/dev/null 2>&1; then
    if command -v apt >/dev/null 2>&1; then
      sudo apt update -y >>"$LOG" 2>&1
      sudo apt install -y dmidecode >>"$LOG" 2>&1 || true
    fi
  fi

  if command -v dmidecode >/dev/null 2>&1; then
    firmware=$(sudo dmidecode -s bios-version 2>/dev/null | head -n1)
    raw_name=$(sudo dmidecode -s baseboard-product-name 2>/dev/null | head -n1)
    manufacturer=$(sudo dmidecode -s baseboard-manufacturer 2>/dev/null | head -n1)
  fi

  raw_name="${raw_name%% *}"        # strip everything after first space
  manufacturer="${manufacturer%% *}"

  # ── ONE giant case statement to rule them all ──
  case "$raw_name" in
    DRFXL|DRFXL*)                              display_name="BD795i SE" ;;
    B75|B75-*)                                 display_name="Biostar TB75" ;;
    TB85|TB85-*)                               display_name="Biostar TB85" ;;
    TB250-BTC|TB250-BTC*)                      display_name="Biostar TB250-BTC" ;;
    TB360-BTC|TB360-BTC*)                      display_name="Biostar TB360-BTC" ;;
    B250|B250-*)                               display_name="ASUS / MSI Mining Expert" ;;

    # ASUS ROG / Prime
    "ROG CROSSHAIR VII HERO"|"CROSSHAIR VII HERO"* ) display_name="ASUS ROG Crosshair VII Hero" ;;
    "ROG CROSSHAIR VIII"* )                    display_name="ASUS ROG Crosshair VIII $raw_name" ;;
    "ROG STRIX"* )                             display_name="ASUS ROG Strix $raw_name" ;;
    "PRIME X570"*|"PRIME B550"* )              display_name="ASUS Prime $raw_name" ;;

    # MSI
    "MEG X570"*"ACE"*|"MEG X570"*"UNIFY"* )    display_name="MSI MEG X570 $raw_name" ;;
    "MPG X570"*|"MPG B550"* )                  display_name="MSI MPG $raw_name" ;;
    "B550"*|"X570"* )                          display_name="MSI $raw_name" ;;

    # Gigabyte Aorus
    "X570 AORUS"*)                             display_name="Gigabyte X570 Aorus $raw_name" ;;
    "B550 AORUS"*)                             display_name="Gigabyte B550 Aorus $raw_name" ;;

    # ASRock
    "X570 Taichi"|"X570 Phantom"*)             display_name="ASRock $raw_name" ;;

    # Generic / unknown – still look nice
    *) if [[ "$manufacturer" != "Unknown" && "$raw_name" != "Unknown" ]]; then
         display_name="$manufacturer $raw_name"
       else
         display_name="${raw_name:-System Product Name}"
       fi ;;
  esac

  # ── Export ──
  MB_FIRMWARE="${firmware:-Unknown}"
  MB_NAME="$display_name"
  MB_RAW_NAME="${raw_name:-Unknown}"
  MB_MANUFACTURER="${manufacturer:-Unknown}"

  log "Motherboard: $MB_NAME (raw: $MB_RAW_NAME) | Firmware: $MB_FIRMWARE"
}

# ---- Metrics via miner-status ------------------------------------------------
# Ensures jq exists, calls the TCP endpoint once, and fills globals:
#   HR_NOW TEMP_NOW WATTS_NOW  (integers; 0 on failure)
get_metrics_now() {
  local json hr tc wt

  # jq (quiet install if missing)
  if ! command -v jq >/dev/null 2>&1; then
    log "Installing jq for JSON parsing..."
    apt update -y >>"$LOG" 2>&1 && apt install -y jq >>"$LOG" 2>&1 || true
  fi

  # netcat variants differ; try GNU -w/-q combo if available
  if printf '%s\r\n' "$MINER_PASS" | nc -h 2>&1 | grep -q -- '-q '; then
    json=$(printf '%s\r\n' "$MINER_PASS" | nc -w 3 -q 1 "$MINER_HOST" "$MINER_PORT" 2>>"$LOG" || true)
  else
    json=$(printf '%s\r\n' "$MINER_PASS" | nc -w 3 "$MINER_HOST" "$MINER_PORT" 2>>"$LOG" || true)
  fi

  if [ -z "$json" ]; then
    log "NOTICE: miner-status returned empty response"
    HR_NOW=0; TEMP_NOW=0; WATTS_NOW=0
    return 1
  fi

  # Parse integers; enforce numeric, strip nulls
  hr=$(printf '%s' "$json" | jq -r '.hashrate // 0' 2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  tc=$(printf '%s' "$json" | jq -r '.temp // 0'      2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  wt=$(printf '%s' "$json" | jq -r '.watts // 0'     2>>"$LOG" | awk 'NF{printf "%.0f",$1}')

  [[ "$hr" =~ ^[0-9]+$ ]] || hr=0
  [[ "$tc" =~ ^[0-9]+$ ]] || tc=0
  [[ "$wt" =~ ^[0-9]+$ ]] || wt=0

  HR_NOW="$hr"
  TEMP_NOW="$tc"
  WATTS_NOW="$wt"
  return 0
}

# Same, but fills HR_AFTER/TEMP_AFTER/WATTS_AFTER
get_metrics_after() {
  local json hr tc wt

  if ! command -v jq >/dev/null 2>&1; then
    apt update -y >>"$LOG" 2>&1 && apt install -y jq >>"$LOG" 2>&1 || true
  fi

  if printf '%s\r\n' "$MINER_PASS" | nc -h 2>&1 | grep -q -- '-q '; then
    json=$(printf '%s\r\n' "$MINER_PASS" | nc -w 3 -q 1 "$MINER_HOST" "$MINER_PORT" 2>>"$LOG" || true)
  else
    json=$(printf '%s\r\n' "$MINER_PASS" | nc -w 3 "$MINER_HOST" "$MINER_PORT" 2>>"$LOG" || true)
  fi

  hr=$(printf '%s' "$json" | jq -r '.hashrate // 0' 2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  tc=$(printf '%s' "$json" | jq -r '.temp // 0'      2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  wt=$(printf '%s' "$json" | jq -r '.watts // 0'     2>>"$LOG" | awk 'NF{printf "%.0f",$1}')

  [[ "$hr" =~ ^[0-9]+$ ]] || hr=0
  [[ "$tc" =~ ^[0-9]+$ ]] || tc=0
  [[ "$wt" =~ ^[0-9]+$ ]] || wt=0

  HR_AFTER="$hr"
  TEMP_AFTER="$tc"
  WATTS_AFTER="$wt"
}

perform_system_update() {
  log "Waiting 1 minute before system upgrade..."
  sleep 60

  log "Stopping xmrig before system upgrade..."
  systemctl stop xmrig >>"$LOG" 2>&1 || true

  log "Running full Debian system upgrade..."
  export DEBIAN_FRONTEND=noninteractive
  apt-get update >>"$LOG" 2>&1
  apt-get -y -o Dpkg::Options::=--force-confdef -o Dpkg::Options::=--force-confold full-upgrade >>"$LOG" 2>&1
  apt-get -y autoremove >>"$LOG" 2>&1 || true
}

# ---- Begin -------------------------------------------------------------------
log "Starting XMRig Auto Update..."
log "==============================="
log "Checking for XMRig updates..."

if ! command -v curl >/dev/null 2>&1; then
  log "Installing curl..."
  apt update -y >>"$LOG" 2>&1 && apt install -y curl >>"$LOG" 2>&1
fi

# Local version
LOCAL_VER=""
if [ -x "$BIN" ]; then
  LOCAL_VER=$("$BIN" --version 2>/dev/null | head -n1 | grep -oE '[0-9]+(\.[0-9]+)*')
fi
if [ -z "$LOCAL_VER" ]; then
  cd "$REPO_DIR" 2>/dev/null || { log "ERROR: cannot cd $REPO_DIR"; exit 1; }
  LOCAL_VER=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//')
fi
[ -z "$LOCAL_VER" ] && LOCAL_VER="(unknown)"

get_metrics_now || true
get_motherboard_firmware

# Latest version
LATEST_VER=$(curl -s "$GITHUB_API" | grep -oP '"tag_name":\s*"\Kv?[0-9.]+' | sed 's/^v//')
if [ -z "$LATEST_VER" ]; then
  log "ERROR: Failed to fetch latest version from GitHub."
  perform_system_update

  EMAIL_SUBJECT="$HOSTNAME_STR XMRig Check Error"
  log "Sending email: $EMAIL_SUBJECT"
  log "Rebooting after email is sent to apply updates."

  host_email_delay
  send_email "$EMAIL_SUBJECT" "[$(ts)] Could not fetch latest version.
See $LOG"
  log "Rebooting to apply updates..."
  /sbin/reboot
  exit 0
fi

log "Local : $LOCAL_VER | HR: ${HR_NOW:-0} H/s | Temp: ${TEMP_NOW:-0} C | Watts: ${WATTS_NOW:-0} W"
log "Latest: $LATEST_VER"

# Already current
if [ "$LOCAL_VER" = "$LATEST_VER" ]; then
  log "Already up to date."

  perform_system_update

  EMAIL_SUBJECT="$HOSTNAME_STR XMRig Current V$LOCAL_VER ${HR_NOW:-0} H/s (${TEMP_NOW:-0}C, ${WATTS_NOW:-0}W)"
  log "Sending email: $EMAIL_SUBJECT"
  log "Rebooting after email is sent to apply updates."

  BODY="Host: $HOSTNAME_STR
When: $(ts)
Status: XMRig is current.
Local version:  $LOCAL_VER
Latest version: $LATEST_VER
Hashrate (now): ${HR_NOW:-0} H/s
CPU Temp:       ${TEMP_NOW:-0} C
Watts:          ${WATTS_NOW:-0} W
Motherboard:    $MB_NAME
Motherboard Firmware: $MB_FIRMWARE

=====================================
 Last 200 lines of xmrig_update.log
=====================================
$(awk 'index($0,"Starting XMRig Auto Update"){last=NR} {lines[NR]=$0} END{start=last?last:(NR-199); if(start<1) start=1; for(i=start;i<=NR;i++) print lines[i] }' "$LOG" 2>/dev/null | tail -n 200)"

  host_email_delay
  send_email "$EMAIL_SUBJECT" "$BODY"
  log "Rebooting to apply updates..."
  /sbin/reboot
  exit 0
fi

# ----- Update -----
log "Update available. Stopping service..."
systemctl stop xmrig >>"$LOG" 2>&1

cd "$REPO_DIR" || { log "ERROR: cannot cd $REPO_DIR"; exit 1; }
log "Fetching tags..."
git fetch --all --tags >>"$LOG" 2>&1
log "Checking out v$LATEST_VER..."
git checkout "v$LATEST_VER" >>"$LOG" 2>&1 || git checkout "$LATEST_VER" >>"$LOG" 2>&1

log "Building..."
mkdir -p "$BUILD_DIR"
cd "$BUILD_DIR" || { log "ERROR: cannot cd $BUILD_DIR"; exit 1; }
cmake .. >>"$LOG" 2>&1 && make -j"$(nproc)" >>"$LOG" 2>&1

if [ ! -x "$BIN" ]; then
  log "ERROR: XMRig binary not built: $BIN missing"
  host_email_delay
  send_email "$HOSTNAME_STR XMRig Build FAILED" "make succeeded but $BIN not executable.\n\n$(tail -50 "$LOG")"
  exit 1
fi
if ! "$BIN" --version 2>/dev/null | grep -q "$LATEST_VER"; then
  log "ERROR: Version mismatch after build. Expected $LATEST_VER"
  host_email_delay
  send_email "$HOSTNAME_STR XMRig Build FAILED" "Built binary does not report version $LATEST_VER.\n\n$("$BIN" --version 2>&1 || echo 'No version')\n\n$(tail -50 "$LOG")"
  exit 1
fi

log "Restarting xmrig..."
systemctl restart xmrig >>"$LOG" 2>&1
log "Update complete."

log "Waiting 5 minutes for new hashrate to stabilize..."
sleep 300

NEW_VER=$("$BIN" --version 2>/dev/null | head -n1 | grep -oE '[0-9]+(\.[0-9]+)*')
[ -z "$NEW_VER" ] && NEW_VER="$LATEST_VER"

get_metrics_after || true
log "Now running: $NEW_VER | HR: ${HR_AFTER:-0} H/s | Temp: ${TEMP_AFTER:-0} C | Watts: ${WATTS_AFTER:-0} W"
perform_system_update

EMAIL_SUBJECT="$HOSTNAME_STR Updated to V$NEW_VER ${HR_AFTER:-0} H/s (${TEMP_AFTER:-0}C, ${WATTS_AFTER:-0}W)"
log "Sending email: $EMAIL_SUBJECT"
log "Rebooting after email is sent to apply updates."

BODY="Host: $HOSTNAME_STR
When: $(ts)
Action: XMRig auto-update applied
From: $LOCAL_VER
To:   $NEW_VER
Hashrate (before/after): ${HR_NOW:-0} / ${HR_AFTER:-0} H/s
CPU Temp (before/after): ${TEMP_NOW:-0} / ${TEMP_AFTER:-0} C
Watts (before/after):    ${WATTS_NOW:-0} / ${WATTS_AFTER:-0} W
Motherboard:             $MB_NAME
Motherboard Firmware:    $MB_FIRMWARE
Service: xmrig.service (restarted)


=====================================
 Last 200 lines of xmrig_update.log
=====================================
$(awk 'index($0,"Starting XMRig Auto Update"){last=NR} {lines[NR]=$0} END{start=last?last:(NR-199); if(start<1) start=1; for(i=start;i<=NR;i++) print lines[i] }' "$LOG" 2>/dev/null | tail -n 200)"

host_email_delay
send_email "$EMAIL_SUBJECT" "$BODY"
log "Rebooting to apply updates..."
/sbin/reboot
exit 0
#########################################################
Ctrl-O, Enter, Ctrl-X




Command:   sudo chmod +x /usr/local/bin/xmrig-auto-update.sh

Command:   sudo crontab -e
Choose:  1
Add this to the bottom:     17 2 * * 0 /usr/local/bin/xmrig-auto-update.sh

Test it manually:    sudo /usr/local/bin/xmrig-auto-update.sh

	System will auto reboot after 1 minute if it works

Check the log:    sudo tail -n 30 /var/log/xmrig_update.log 






