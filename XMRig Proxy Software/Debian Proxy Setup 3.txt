

********************  COMMON COMMANDS  ********************

Clear the watchdog log:   sudo truncate -s 0 /var/log/proxy-watchdog.log

View the watchdog log:   sudo tail -n 50 /var/log/proxy-watchdog.log

View the watchdog log live:    sudo tail -f /var/log/proxy-watchdog.log

Watchdog Status:   sudo systemctl status proxy-watchdog   















********************  TEST LED   ********************


Verify LED is connected:    ls -l /dev/ttyACM* /dev/ttyUSB* 2>/dev/null
    Must how crw, 166 and ttyACM0 as below.
crw-rw---- 1 root dialout 166, 0 Nov 26 21:20  /dev/ttyACM0

Erase corrupted port config:   sudo rm /dev/ttyACM0

INIT THE LED:   sudo stty -F /dev/ttyACM0 9600 raw -echo -echoe -echok -echoctl -echoke

SET RED:   echo "#FF0000" | sudo tee /dev/ttyACM0 >/dev/null

SET GREEN:   echo "#00FF00" | sudo tee /dev/ttyACM0 >/dev/null














********************  SYSTEM STABILITY LOG   ********************

This is required to be installed so the 5 minute startup email can show any system stability issues.

Command:   sudo apt install rasdaemon
Command:   sudo systemctl enable --now rasdaemon

Check the log:   sudo ras-mc-ctl --errors


















********************  PROXY WATCHDOG   ********************


Command:   sudo nano /usr/local/bin/proxy-watchdog.sh
#########################################################
#!/bin/bash
# proxy-watchdog.sh — Monitors xmrig-proxy via proxy-status server and enforces auto-reboot rules
# (c) 2026 Nathan Gwozdecki
# Version
# 1.1 - first version
# 1.1 - led status is saved to a file
# 1.2 - added 1 hour hash rate average.
# 1.3 - neatened LED code, added dependency check.
# 1.4 - added 10 second delay before sending email

set -Eeuo pipefail      		       # note the extra -E so ERR fires in functions/$(...)

#set -x   #(REMOVE)  Use this for debugging crashes by logging all commands
         #Command to clear the log:   sudo truncate -s 0 /var/log/proxy-watchdog.log
         #Command to search the log:   tac /var/log/proxy-watchdog.log | grep -i -m 1 -C 5 "line" | tac

[ -f /etc/proxy.env ] && . /etc/proxy.env      # load shared configuration (STATUS_PORT, STATUS_TOKEN, XMRIG vars, etc.)

# ---- single-instance lock ----
exec {LOCKFD}<>/run/proxy-watchdog.lock || exit 0
flock -n "$LOCKFD" || exit 0

LOG="/var/log/proxy-watchdog.log"

LOOP_INTERVAL=10   #DO NOT SET LESS THAN 6 SECONDS

# --- Default Thresholds if not found in proxy.env  ---
CPU_LOW="${CPU_LOW:-0}"
CPU_HIGH="${CPU_HIGH:-45}"
CPU_WARN="${CPU_WARN:-40}"
HASH_LOW_5M="${HASH_LOW_5M:-8000}"
HASH_LOW_30M="${HASH_LOW_30M:-10000}"
LED_BRT="${LED_BRT:-50}"
MINERS_TOT="${MINERS_TOT:-0}"
MINERS_IPS="${MINERS_IPS:-}"


printf '%s Using thresholds: CPU_LOW=%s CPU_WARN=%s CPU_HIGH=%s HASH_LOW_5M=%s HASH_LOW_30M=%s\n' \
  "$(date '+%F %T')" "$CPU_LOW" "$CPU_WARN" "$CPU_HIGH" "$HASH_LOW_5M" "$HASH_LOW_30M" >>"$LOG"

COOL_LIMIT_MIN=5
LOWHASH5_LIMIT_MIN=5
LOWHASH30_LIMIT_MIN=30
CPU_HIGH_MIN=5

# --- Convert minutes to seconds ---
COOL_LIMIT_SEC=$((COOL_LIMIT_MIN*60))
LOWHASH5_LIMIT_SEC=$((LOWHASH5_LIMIT_MIN*60))
LOWHASH30_LIMIT_SEC=$((LOWHASH30_LIMIT_MIN*60))
CPU_HIGH_LIMIT_SEC=$((CPU_HIGH_MIN*60))
REBOOT_GUARD_SEC=3600   #1 hour

# --- Counters/State ---
CoolSecs=0
LowHash5Secs=0
LowHash30Secs=0
CPUHighSec=0
LowMinersSec=0
reboot_defer=0
StartupEPOCH=$(date +%s)        
StartupEmailSent=0      
DNSGood=1             # pings google every 24 hours to show internet is working
LastMidnightRun=""    # Tracks the last date we ran the midnight function
LEDStatus=""          # Shows LED status to other scripts by writing to a file
LED_TTY_PATH=""       # Port Location of the LED

# For change detection
LastHR=0
LastTC=0
LastWK=0
LastCoolSecs=0
LastLow5Secs=0
LastLow30Secs=0
LastCPUHighSec=0
LastLowMinersSec=0
LastLoggedHour=""

# Current proxy metrics
HR=0                  # Hashrate in H/s
TC=0                  # CPU temperature in °C
WT=0                  # CPU Power
WK=0                  # Number of workers / miners
LS=""                 # LED Status

# Global declarations for average hash rate
declare -g -a HashArray=()           # the array (dynamic/sparse)
declare -g HashArrayPos=-1           # -1 = empty, then cycles 0..359
declare -g HashArrayLen=0            # 0..360 (number of valid elements)
declare -g HashAverage=0             # current average


HOSTNAME_STR="$(hostname)"
EMAIL_LIB="/usr/local/bin/send_email.sh"

# --- Import email function ---
if [ -r "$EMAIL_LIB" ]; then
  source "$EMAIL_LIB"
else
  send_email() { echo "[WARN] send_email.sh missing — $1: $2" >>"$LOG"; }
fi

ts() { date '+%Y-%m-%d %H:%M:%S'; }
log() { printf '%s %s\n' "$(ts)" "$*" >>"$LOG"; }

# Capture all stderr from the script into the log
exec 2>>"$LOG"


check_dependencies() {
  log "Checking required system dependencies..."

  local missing_required=0 cmd
  local required_cmds=(bash date ip ss jq nc timeout awk sed grep journalctl systemctl hostname curl traceroute ras-mc-ctl timedatectl dmesg getent udevadm stty)

  for cmd in "${required_cmds[@]}"; do
    command -v "$cmd" >/dev/null 2>&1 || { log "ERROR: Required dependency missing: $cmd"; missing_required=1; }
  done

  if (( missing_required == 0 )); then
    log "Dependency check passed: all required commands present"
  else
    log "ERROR: One or more REQUIRED dependencies are missing — watchdog may not function correctly"
  fi
}




# --- Reboot email diagnostics (network/session snapshots) ---

# diag_block() {
#   local label="$1"; shift
#   printf '\n\n========== %s ==========\n\n' "$label"   # two newlines: one after header, one blank line

#   local output
#   output=$("$@" 2>&1 || true)
#   if [ -n "$output" ]; then
#     echo "$output" | sed 's/^/   /'   # echo preserves newlines perfectly
#     printf '\n'                      # blank line after content
#   else
#     printf '   (no output)\n\n'
#   fi

#   printf '\n'   # ← This guarantees a blank line after every diag_block
# }

diag_block() {
  local label="$1"; shift
  local output
  output=$("$@" 2>&1 || true)

  {
    printf '\n\n========== %s ==========\n\n' "$label"
    if [ -n "$output" ]; then
      echo "$output" | sed 's/^/   /'
      printf '\n'
    else
      printf '   (no output)\n\n'
    fi
    printf '\n'
  }
}



# Simple, busybox-friendly traceroute formatter (updated)
format_traceroute() {
  local title="$1"
  local raw_output="$2"
  local has_hops=0

  printf '\n\n========== %s ==========\n\n' "$title"

  # Print the header, indented
  echo "$raw_output" | head -n1 | sed 's/^/ /'

  # Process hop lines using process substitution to avoid subshell
  while IFS= read -r line; do
    # Trim whitespace
    line=$(printf '%s' "$line" | sed 's/^[ \t]*//; s/[ \t]*$//')
    
    # Skip empty lines and full "* * *" lines
    [[ -z "$line" ]] && continue
    [[ "$line" == "* * *" ]] && continue
    
    # Only process lines that start with a number (hop lines)
    if [[ "$line" =~ ^[0-9] ]]; then
      printf ' %s hop: %s\n' "$((++has_hops))" "$line"
    fi
  done < <(echo "$raw_output" | tail -n+2)

  if [ "$has_hops" -eq 0 ]; then
    printf '  (No intermediate routers responded to probes – this is very common on the internet and usually means nothing is wrong)\n'
  fi
}

collect_reboot_diags() {
  local out=""
  local router_ip="${DIAG_ROUTER_IP:-192.168.1.1}"
  local wan_ip="${DIAG_WAN_IP:-1.1.1.1}"
  local wan_name="Cloudflare DNS (1.1.1.1)"

  out+="When: $(ts)"$'\n'
  out+="Device: $HOSTNAME_STR"$'\n'
  out+=$'\n'
  out+="IMPORTANT NOTES:"$'\n'
  out+=" • This report shows the network state exactly when the email was sent – it's a snapshot, not a full history."$'\n'
  out+=" • The ping tests only check if we can reach your router and one public internet address. They do NOT test the mining pools directly."$'\n'
  out+=" • DNS checks below only show if pool names can be turned into IP addresses – no actual mining traffic is sent."$'\n'
  out+=" • Active connection lists only show connections that are open right now. Empty lists are completely normal if the miner is idle or using a different pool."$'\n'
  out+=$'\n'

  out+="--- QUICK NETWORK SUMMARY (at the moment this report was created) ---\n\n"

  local def_route def_if src_ip
  def_route="$(ip route show default 2>/dev/null | head -n1 || true)"
  def_if="$(awk '/default/ {for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}' <<<"$def_route" 2>/dev/null || true)"
  src_ip="$(ip -4 -br addr show "${def_if:-}" 2>/dev/null | awk '{print $3}' | cut -d/ -f1 | head -n1 || true)"

  local ping_router_ok="FAIL" ping_wan_ok="FAIL"
  ping -c 1 -W 1 "$router_ip" >/dev/null 2>&1 && ping_router_ok="OK"
  ping -c 1 -W 1 "$wan_ip" >/dev/null 2>&1 && ping_wan_ok="OK"

  out+="How internet traffic leaves this device : ${def_route:-'(no internet route found)'}"$'\n'
  out+="Main network interface                 : ${def_if:-'(unknown)'}"$'\n'
  out+="Device's own IP address                : ${src_ip:-'(none detected)'}"$'\n'
  out+="Can reach router (local network)       : ${ping_router_ok} (${router_ip})"$'\n'
  out+="Can reach internet                     : ${ping_wan_ok} (${wan_name})"$'\n'
  out+=$'\n'

  out+=$(diag_block "Full routing table – shows exactly how this device sends traffic out" \
    bash -lc 'ip route')

  out+=$'\n'$(diag_block "Network interfaces status – 'UP' means cable connected / Wi-Fi associated" \
    bash -lc 'ip -br link')

  out+=$'\n'$(diag_block "All IP addresses assigned to this device" \
    bash -lc 'ip -br addr')

  out+=$'\n'$(diag_block "Reachability test to router – sending 5 pings to your gateway (${router_ip})" \
    bash -lc "ping -c 5 -W 1 $router_ip")

  out+=$'\n'$(diag_block "Internet reachability test – sending 5 pings to ${wan_name}" \
    bash -lc "ping -c 5 -W 1 $wan_ip")

  # Traceroute to internet
  local tr_internet="$(traceroute -n -w 2 -q 2 $wan_ip 2>/dev/null || echo 'traceroute failed or not available')"
  out+=$'\n'$(format_traceroute "Path to internet (traceroute to Cloudflare DNS) – helps spot slow or blocked hops" "$tr_internet")

  out+=$'\n'

  # Traceroute to each pool
  local p host tr_pool
  for p in $DIAG_POOLS; do
    host="${p%%:*}"
    port="${p##*:}"

    # Run traceroute ONCE, capture all output; don't leak to top of email
    if tr_pool="$(traceroute -n -w 2 -q 2 "$host" 2>&1)"; then
      :
    else
      tr_pool="traceroute failed (host: $host)"
    fi

    out+="$(format_traceroute "Path to mining pool ($host) – checks route to pool server" "$tr_pool")"
    out+=$'\n'
  done


  out+=$(diag_block "DNS servers this device is using – wrong ones can prevent pool names from resolving" \
    bash -lc 'cat /etc/resolv.conf || systemd-resolve --status 2>/dev/null || true')

  out+=$'\n\n\n========== Port reachability to each mining pool (secure mining port – Open = good) ==========\n'
  for p in $DIAG_POOLS; do
    host="${p%%:*}"
    port="${p##*:}"
    out+=$'\n'"Pool hostname: $host:$port"
    timeout 5 bash -c "echo > /dev/tcp/$host/$port" >/dev/null 2>&1 \
      && out+="   :   Open (connection succeeded)"$'\n' \
      || out+="   :   Blocked or timeout"$'\n'
  done





  # Extra detail to help distinguish DNS issues, IPv6 issues, and TLS/443 blocking
  out+=$'\n\n========== Extra connectivity details for each mining pool (DNS + TLS probe) ==========\n'
  for p in $DIAG_POOLS; do
    host="${p%%:*}"
    port="${p##*:}"

    out+=$'\n'"Pool hostname: $host:$port"$'\n'

    # --- DNS resolution details (both IPv4 and IPv6 if present) ---
    local ahosts
    ahosts="$(getent ahosts "$host" 2>/dev/null || true)"
    if [ -n "$ahosts" ]; then
      out+="Resolved addresses via getent ahosts:"$'\n'
      out+="$ahosts"$'\n'
    else
      out+="Resolved addresses via getent ahosts: (none – DNS lookup failed)"$'\n'
    fi

    # --- Simple IPv4-only extraction (helps catch “IPv6 works, IPv4 blocked” cases) ---
    local ipv4_list
    ipv4_list="$(printf '%s\n' "$ahosts" | awk '/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/ {print $1}' || true)"
    if [ -n "$ipv4_list" ]; then
      out+="IPv4 addresses used for testing:"$'\n'
      out+="$ipv4_list"$'\n'
    else
      out+="IPv4 addresses used for testing: (none – hostname may be IPv6-only)"$'\n'
    fi

    # --- TLS / HTTPS probe with curl (only if curl is installed) ---
    if command -v curl >/dev/null 2>&1; then
      local curl_out
      # We only keep the first ~12 lines so the email doesn't explode
      curl_out="$(
        curl -v --connect-timeout 5 --max-time 5 "https://$host:$port" </dev/null 2>&1 \
          | sed -n '1,12p' \
          || true
      )"
      if [ -n "$curl_out" ]; then
        out+="curl -v TLS probe (first lines):"$'\n'"$curl_out"$'\n'
      else
        out+="curl -v TLS probe: (no output – likely hard timeout)"$'\n'
      fi
    else
      out+="curl not installed – skipping TLS probe on $host:$port"$'\n'
    fi
  done



  # Extra per-IP port test so we can see which Hashvault backend is failing
  out+=$'\n\n========== Per-IP port reachability for each mining pool (helps debug Hashvault) ==========\n'
  for p in $DIAG_POOLS; do
    host="${p%%:*}"
    port="${p##*:}"

    out+=$'\n'"Pool hostname: $host:$port"$'\n'

    # Get unique IPv4 addresses for this host
    local ahosts ipv4_list ip any_ok
    ahosts="$(getent ahosts "$host" 2>/dev/null || true)"
    ipv4_list="$(printf '%s\n' "$ahosts" \
                  | awk '/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/ {print $1}' \
                  | sort -u)"

    if [ -z "$ipv4_list" ]; then
      out+="   (No IPv4 addresses found – DNS failure or IPv6-only host)\n"
      continue
    fi

    any_ok=0
    for ip in $ipv4_list; do
      if timeout 5 bash -lc "echo > /dev/tcp/$ip/$port" >/dev/null 2>&1; then
        out+="   [$ip] : Open (TCP handshake succeeded)\n"
        any_ok=1
      else
        out+="   [$ip] : Blocked or timeout\n"
      fi
    done

    if (( any_ok == 1 )); then
      out+="   Overall: at least one backend reachable\n"
    else
      out+="   Overall: ALL backends failed – this really looks blocked\n"
    fi
  done












  out+=$'\n\n========== ICMP ping reachability to each mining pool (5 packets) – checks basic IP-level reachability ==========\n\n'
  out+="Note: Many mining pools block or ignore pings – FAIL here is often normal and does NOT mean mining won't work.\n"
  firstline=1
  for p in $DIAG_POOLS; do
    host="${p%%:*}"
    port="${p##*:}"
    out+="\n\nPool hostname: $host:$port"
    out+=$'\n'
    if (( firstline )); then
      firstline=0
      out+=$'\n'
    fi
    # getent may fail; don't let that kill the loop
    local ip="$(getent ahosts "$host" 2>/dev/null | awk '/^[0-9.]/{print $1; exit}' || true)"
    if [ -n "$ip" ]; then
      local ping_result="$(ping -c 5 -W 1 "$ip" 2>&1 || true)"
      out+="$ping_result"$'\n'
      if grep -q "100% packet loss" <<<"$ping_result"; then
        out+="Result: FAIL (100% loss)"$'\n'
      else
        local loss="$(grep "packet loss" <<<"$ping_result" | awk '{print $(NF-4)}' | tr -d '%')"
        local avg="$(grep "rtt min/avg/max" <<<"$ping_result" | awk -F'/' '{print $5}')"
        out+="Result: OK (${loss}% loss, avg RTT ${avg:-unknown} ms)"$'\n'
      fi
    else
      out+="Could not resolve to IPv4 address – skipping ping."$'\n'
    fi
  done


  out+=$(diag_block "Currently active secure (TLS) connections to port 443 – mining pools usually use this" \
    bash -lc "ss -tnip '( dport = :443 )' | tail -n +2 | sed 's/^/ /'" || true)

  if [ -n "${DIAG_POOLS:-}" ]; then
    out+=$'\n\n'
    out+=$'\n========== Raw ss output for each mining pool (advanced detail) =========\n\n'
    for p in $DIAG_POOLS; do
      host="${p%%:*}"
      port="${p##*:}"
      out+="Pool hostname: $host:$port\n"
      local ip="$(getent ahosts "$host" 2>&1 | awk 'NR==1{print $1}' || true)"
      if [ -n "$ip" ]; then
        out+="Resolved IP: $ip\n\n"
        local conn="$(ss -tnpi "dst $ip:$port" 2>&1 || true)"
        if [[ -n "$conn" && "$conn" != *"No such file"* ]]; then
          out+="$conn\n\n"                  # ss output with its own header + blank line after
        else
          out+="No active connections right now.\n\n"
        fi
      else
        out+="Could not resolve hostname.\n\n"
      fi
    done
  fi


  out+=$(diag_block "MTU test to internet – fragmentation issues can cause mining dropouts" \
    bash -lc "ping -c 1 -M do -s 1472 $wan_ip || true")

  out+=$'\n'$(diag_block "System clock and time synchronization – clock jumps can break TLS connections" \
    bash -lc 'timedatectl')

  out+=$'\n'$(diag_block "Recent kernel messages (last 40 lines) – for Wi-Fi drops, cable issues, etc." \
    bash -lc 'dmesg | tail -n 40')

  printf '%s\n' "$out"
}






calc_average_hash() {     # Function: add new hash rate and recalculate average
    local new_hash="$1"
    local sum=0
    local i

    HashArrayPos=$(( (HashArrayPos + 1) % 360 ))  # Advance position (circular wrap-around)
    HashArray[HashArrayPos]="$new_hash"           # Store the new value (overwrites old one when full)
    if (( HashArrayLen < 360 )); then HashArrayLen=$(( HashArrayLen + 1 )); fi

    sum=0      # Calculate current sum of all valid elements
    for ((i = 0; i < HashArrayLen; i++)); do
        # Use :-0 to treat empty/unset array slots as 0
        (( sum += ${HashArray[i]:-0} ))
    done

    HashAverage=$(( sum / HashArrayLen ))
}



collect_show_miners() {
  local log_file="/var/log/xmrig-proxy.log"
  local output=""
  local i=1
  local ip
  local log_lines=""

  if [ -z "$MINERS_IPS" ]; then
    echo "No IP addresses have been added to proxy.env MINERS_IPS"
    return 0
  fi

  if [ ! -f "$log_file" ]; then
    echo "Could not find xmrig-proxy.log"
    return 0
  fi

  # Get ONLY last 3 minutes of log lines (xmrig-proxy.log format: [YYYY-MM-DD HH:MM:SS.mmm] ...)
  local since_ts
  since_ts="$(date -d '3 minutes ago' '+%F %T')"

  log_lines="$(
    awk -v since="$since_ts" '
      {
        # $1 is like "[2026-01-09"
        # $2 is like "15:16:48.721]"
        d=$1; t=$2
        gsub(/^\[/,"",d)
        gsub(/\]$/,"",t)
        sub(/\..*/,"",t)          # drop .mmm so we compare to "HH:MM:SS"
        if (d" "t >= since) print
      }
    ' "$log_file" 2>/dev/null
  )"

  for ip in $MINERS_IPS; do
    if ! grep -q -- "$ip" <<< "$log_lines"; then
      output+="Miner$i $ip OFF LINE"$'\n'
    else
      if get_metrics "$ip"; then
        output+="Miner$i $ip Working ($HR H/s, $TC C, $WT W, LED $LS)"$'\n'
      else
        output+="Miner$i $ip Working (no stats)"$'\n'
      fi
    fi
    ((i++))
  done

  printf '%s\n' "$output"
}



uptime_text() {
  local uptime_str="Unknown"

  if ! systemctl is-active --quiet xmrig-proxy 2>/dev/null; then
    printf '%s' "$uptime_str"
    return 0
  fi

  local start_time start_sec now_sec seconds

  start_time="$(systemctl show xmrig-proxy --property=ActiveEnterTimestamp --value 2>/dev/null || true)"
  [[ -z "$start_time" ]] && { printf '%s' "$uptime_str"; return 0; }

  now_sec="$(date +%s)"
  start_sec="$(date -d "$start_time" +%s 2>/dev/null || echo "")"

  # Fallback if date parsing failed or is not numeric
  [[ "$start_sec" =~ ^[0-9]+$ ]] || start_sec="$now_sec"

  seconds=$(( now_sec - start_sec ))
  (( seconds < 0 )) && seconds=0

  if (( seconds >= 86400 )); then
    local whole_days=$(( seconds / 86400 ))
    local remainder=$(( seconds % 86400 ))
    local fraction=$(( (remainder * 10) / 86400 ))   # 0–9
    uptime_str=$(printf "%d.%d Days" "$whole_days" "$fraction")

  elif (( seconds >= 3600 )); then
    local whole_hours=$(( seconds / 3600 ))
    local remainder=$(( seconds % 3600 ))
    local fraction=$(( (remainder * 10) / 3600 ))
    uptime_str=$(printf "%d.%d Hours" "$whole_hours" "$fraction")

  else
    local mins=$(( seconds / 60 ))
    uptime_str="${mins} Minutes"
  fi

  printf '%s' "$uptime_str"
}



send_status_email() {
  local subject="$1"

  # Refresh current metrics (safe even if get_metrics fails)
  get_metrics "127.0.0.1" || true

  # Capture logs
  local XMRIG_PROXY_LOG=""
  XMRIG_PROXY_LOG=$(
    journalctl -u xmrig-proxy -n 1000 --no-pager -o cat 2>/dev/null \
      | awk '/Started xmrig-proxy/ {buf=""} {buf = buf $0 ORS} END {printf "%s", buf}' \
      | tail -500 \
      || echo "(Failed to capture recent xmrig-proxy log)"
  )
  XMRIG_PROXY_LOG=$(echo "$XMRIG_PROXY_LOG" | sed -r "s/\x1B\[[0-9;]*[A-Za-z]//g")

  if [ -z "$XMRIG_PROXY_LOG" ]; then
    XMRIG_PROXY_LOG="(No recent XMRig-Proxy log data)"
  fi

  local MCE_LOG_TAIL=""
  MCE_LOG_TAIL=$(ras-mc-ctl --errors 2>/dev/null | tail -n 100 || echo "(No output from ras-mc-ctl --errors - install rasdaemon if desired)")

  local WATCHDOG_TAIL=""
  WATCHDOG_TAIL=$(tail -n 100 "$LOG" 2>/dev/null || echo "(No proxy-watchdog.log data)")

  local SHOW_MINERS=""
  SHOW_MINERS="$(collect_show_miners 2>&1 || echo "(collect_SHOW_MINERS failed)")"

  local REBOOT_DIAGS=""
  REBOOT_DIAGS="$(collect_reboot_diags 2>&1 || echo "(collect_REBOOT_DIAGS failed)")"

  sleep 10   # wait for network traffic to clear before sending email

  send_email "$subject" "\
Host: $HOSTNAME_STR
Started: $(ts)
Hashrate: $HR H/s     Avg: $HashAverage H/s
CPU Temp: $TC C
Workers: $WK
Uptime: $(uptime_text)
Watchdog active.

==============================
  proxy.env/MINERS_IPS Miners
==============================
$SHOW_MINERS

==============================
     NETWORK DIAGNOSTICS
==============================
$REBOOT_DIAGS

==========================================
 Last 100 lines of ras-mc-ctl --errors
==========================================
$MCE_LOG_TAIL

======================================
 Last 100 lines of proxy-watchdog.log
======================================
$WATCHDOG_TAIL

=================================
Last 500 lines of xmrig-proxy.log
=================================
$XMRIG_PROXY_LOG
" || log "WARN: send_email failed (non-fatal)"
}



exit_trap() {
  local st=$?
  local hr=${HR:-N/A}
  local tc=${TC:-N/A}
  local wk=${WK:-N/A}
  log "WATCHDOG EXITED: status=$st (signal or error), last HR=$hr Temp=$tc Workers=$wk \
cool=${CoolSecs:-0}s hot=${CPUHighSec:-0}s low5=${LowHash5Secs:-0}s low30=${LowHash30Secs:-0}s lowMiners=${LowMinersSec:-0}s"
}

err_trap() {
  local st=$?
  local line=${BASH_LINENO[0]:-0}
  local cmd=${BASH_COMMAND:-unknown}
  log "WATCHDOG ERROR: status=$st at line $line: $cmd (pid=$$, ppid=$PPID)"
  exit "$st"    # re-exit with the same status so EXIT trap sees the error
}

trap exit_trap EXIT
trap err_trap ERR

# Return epoch of the most recent "REBOOT triggered" in $LOG, or 0 if none
last_reboot_epoch() {
  local ts
  ts=$(tac "$LOG" 2>/dev/null | grep -m1 'REBOOT triggered:' | awk '{print $1" "$2}' 2>/dev/null || echo "")
  if [ -n "$ts" ] && date -d "$ts" >/dev/null 2>&1; then
    date -d "$ts" +%s
  else
    echo 0
  fi
}

# --- Miner query ---
get_metrics() {
  local ip="${1:-127.0.0.1}"   # Use provided IP or default to localhost

  local json

  # Query the proxy status server
  json=$(timeout 6 printf '%s\r\n' "$STATUS_TOKEN" | nc -w 2 "$ip" "$STATUS_PORT" 2>>"$LOG" || true)

  # If no response or error in JSON, reset to safe defaults
  if [[ -z "$json" || "$json" == *"error"* ]]; then
    HR=0
    TC=0
    WT=0
    WK=0
    LS="unknown"                  
    return 1
  fi

  # Extract metrics directly into global variables
  HR=$(printf '%s' "$json" | jq -r '.hashrate // 0' 2>/dev/null)
  TC=$(printf '%s' "$json" | jq -r '.temp // 0' 2>/dev/null)
  WT=$(printf '%s' "$json" | jq -r '.watts // 0' 2>/dev/null)
  WK=$(printf '%s' "$json" | jq -r '.workers // 0' 2>/dev/null)
  LS=$(printf '%s' "$json" | jq -r '.led // "off"' 2>/dev/null)

  # Force to "off" if not a valid value (prevents bad state in script)
  if [[ ! "$LS" =~ ^(off|red|green)$ ]]; then
    LS="unknown"
  fi

  # Ensure metrics are valid integers
  [[ "$HR" =~ ^[0-9]+$ ]] || HR=0
  [[ "$TC" =~ ^[0-9]+$ ]] || TC=0
  [[ "$WT" =~ ^[0-9]+$ ]] || WT=0
  [[ "$WK" =~ ^[0-9]+$ ]] || WK=0
}



# --- Safe reboot ---
do_reboot() {
  local REASON="$1"
  log "REBOOT triggered: $REASON"
  internet_check
  send_status_email "$HOSTNAME_STR Proxy Reboot $REASON"
  set_led 0 0 0 || true  #turn off led
  sleep 10
  /sbin/reboot
}


init_led() {
  local d vid pid

  # search for our fit-statUSB (VID:PID 2047:03df) on ttyACM*
  for d in /dev/ttyACM*; do
    [[ -e "$d" ]] || continue
    [[ $(stat -c '%F' "$d" 2>/dev/null) == "character special file" ]] || continue

    vid=$(udevadm info -q property -n "$d" 2>/dev/null | awk -F= '/ID_VENDOR_ID=/ {print $2}')
    pid=$(udevadm info -q property -n "$d" 2>/dev/null | awk -F= '/ID_MODEL_ID=/ {print $2}')

    if [[ "$vid" == "2047" && "$pid" == "03df" ]]; then
      LED_TTY_PATH="$d"
      # configure serial ONCE
      stty -F "$LED_TTY_PATH" 9600 raw -echo -echoe -echok -echoctl -echoke 2>/dev/null || :
      return 0
    fi
  done

  LED_TTY_PATH=""
  return 1
}


set_led() {
  local r="$1" g="$2" b="$3"
  local dev="$LED_TTY_PATH"

  # no configured LED device
  [[ -n "$dev" && -e "$dev" ]] || return 1
  [[ $(stat -c '%F' "$dev" 2>/dev/null) == "character special file" ]] || return 1

  # validate 0–255
  local v
  for v in "$r" "$g" "$b"; do
    [[ "$v" =~ ^[0-9]+$ ]] && (( v >= 0 && v <= 255 )) || return 1
  done

  # convert to hex
  local rh gh bh
  printf -v rh '%02X' "$r"
  printf -v gh '%02X' "$g"
  printf -v bh '%02X' "$b"

  # write safely (no fake node creation)
  echo -e "#${rh}${gh}${bh}\n" | tee "$dev" >/dev/null 2>&1 || return 1

  return 0
}


save_LED() {
  local new_status="$1"   # the status passed to the function: "off", "red", or "green"

  if [[ "$new_status" != "$LEDStatus" ]]; then   # If the new status is different from the last saved one, write it to file
    printf '%s\n' "$new_status" > /var/run/led_status 2>/dev/null || true
    log "LED status changed to: $new_status"
  fi
  LEDStatus="$new_status"
}


internet_check() {
  if curl -s -f --connect-timeout 5 https://www.google.com/ >/dev/null 2>&1; then
    DNSGood=1
    log "Internet check to www.google.com Passed"
  else
    DNSGood=0
    log "ERROR: Internet is not working. Check DNS configuration."
  fi
}





check_dependencies   # show any missing dependencies in the log

# --- Initialize ---
init_led || log "LED init failed (fit-statUSB not found)"

set_led 0 0 0 || true  #turn off led
log "Starting proxy watchdog..."

# --- Main loop ---
while true; do

  get_metrics "127.0.0.1" || true

  now=$(date +%s)

  if (( now - StartupEPOCH >= 240 )); then calc_average_hash "$HR"; fi  # calculate 1 hour average

  last_reboot_ts=$(last_reboot_epoch)   #only reboot once per hour max
  if (( last_reboot_ts > 0 && now - last_reboot_ts < REBOOT_GUARD_SEC )); then
    reboot_defer=1
  else
    reboot_defer=0
  fi

  # ===== Counters =====
  (( TC < CPU_LOW )) && ((CoolSecs+=LOOP_INTERVAL)) || CoolSecs=0
  (( TC > CPU_HIGH )) && ((CPUHighSec+=LOOP_INTERVAL)) || CPUHighSec=0
  (( WK < MINERS_TOT )) && ((LowMinersSec+=LOOP_INTERVAL)) || LowMinersSec=0
  (( HR < HASH_LOW_5M )) && ((LowHash5Secs+=LOOP_INTERVAL)) || LowHash5Secs=0
  (( HR < HASH_LOW_30M )) && ((LowHash30Secs+=LOOP_INTERVAL)) || LowHash30Secs=0

  # ===== Reboot triggers =====
  if (( reboot_defer == 0 )); then
    if (( CoolSecs >= COOL_LIMIT_SEC )); then
      set_led 0 0 0 || true  #turn off led
      do_reboot "CPU below ${CPU_LOW}C for ${COOL_LIMIT_MIN} min"
    elif (( CPUHighSec >= CPU_HIGH_LIMIT_SEC )); then
      set_led 0 0 0 || true  #turn off led
      do_reboot "CPU above ${CPU_HIGH}C for ${CPU_HIGH_MIN} min"
    elif (( LowHash5Secs >= LOWHASH5_LIMIT_SEC )); then
      set_led 0 0 0 || true  #turn off led
      do_reboot "Hashrate below ${HASH_LOW_5M} H/s for ${LOWHASH5_LIMIT_MIN} min"
    elif (( LowHash30Secs >= LOWHASH30_LIMIT_SEC )); then
      set_led 0 0 0 || true  #turn off led
      do_reboot "Hashrate below ${HASH_LOW_30M} H/s for ${LOWHASH30_LIMIT_MIN} min"
    fi
  fi


  # ===== Logging (changes or top of hour) =====
  current_hour=$(date +%H)
  log_needed=false
  diff_hr=$(( HR>LastHR ? HR-LastHR : LastHR-HR ))
  diff_tc=$(( TC>LastTC ? TC-LastTC : LastTC-TC ))

  if (( LastHR == 0 || (diff_hr * 100 / (LastHR + 1)) >= 10 )); then log_needed=true; fi
  if (( LastTC == 0 || diff_tc >= 3 )); then log_needed=true; fi
  if [[ "$LastWK" != "$WK" ]]; then log_needed=true; fi

  if (( CoolSecs - LastCoolSecs >= 60 || LowHash5Secs - LastLow5Secs >= 60 || LowHash30Secs - LastLow30Secs >= 60 || CPUHighSec - LastCPUHighSec >= 60 || LowMinersSec - LastLowMinersSec >= 60 )); then
    log_needed=true
  fi
  if [[ "$current_hour" != "$LastLoggedHour" ]]; then
    log_needed=true; LastLoggedHour="$current_hour"
  fi
  if $log_needed; then
    log "HR=$HR Temp=${TC}°C Workers=${WK} | cool=${CoolSecs}s, hot=${CPUHighSec}s, low5=${LowHash5Secs}s, low30=${LowHash30Secs}s, lowMiners=${LowMinersSec}s"
    LastHR=$HR; LastTC=$TC; LastWK=$WK
    LastCoolSecs=$CoolSecs; LastLow5Secs=$LowHash5Secs; LastLow30Secs=$LowHash30Secs; LastCPUHighSec=$CPUHighSec; LastLowMinersSec=$LowMinersSec
  fi


  # ================= Send 5 minute email =================
  if (( StartupEmailSent == 0 )); then  
    if (( $(date +%s) - StartupEPOCH >= 300 )); then 
      internet_check  
      send_status_email "$HOSTNAME_STR XMRig-Proxy Running (5 min)"
      StartupEmailSent=1
    fi
  fi

  # ================= Send the daily midnight email =================
  current_date=$(date '+%Y-%m-%d')
  if [[ "$current_date" != "$LastMidnightRun" ]] && [[ "$(date '+%H:%M')" < "00:10" ]]; then
    internet_check  
    send_status_email "$HOSTNAME_STR XMRig-Proxy $WK Miners Running"
    LastMidnightRun="$current_date"
  fi

  # ================= Send missing miners email once =================
  if (( LowMinersSec > 1800 && LowMinersSec <= 1860 )); then
    internet_check
    send_status_email "$HOSTNAME_STR XMRig-Proxy $WK Miners Running"
    ((LowMinersSec += 120))
  fi


  # ==== Perfectly synchronized LED pulse to 10 second intervals ====
  now_sec=$(date +%s)
  now_ns=$(date +%N 2>/dev/null || echo "000000000")  # fallback if %N unsupported
  now_frac="${now_ns:0:3}"                            # first 3 digits = milliseconds
  epoch_ms=$(( now_sec * 1000 + 10#$now_frac ))

  # Which 10-second block are we in? (0 or 1)
  block=$(( (epoch_ms / (LOOP_INTERVAL * 1000)) % 2 ))

  # Brightness for current block 
  if (( block == 0 )); then
    PULSE_VAL=$(( LED_BRT ))        
  else
    PULSE_VAL=$(( LED_BRT * 2 ))
    (( PULSE_VAL > 255 )) && PULSE_VAL=255
  fi

  # ==== Sleep exactly to next 10-second boundary (with 150 ms guard) ====
  remaining_ms=$(( (LOOP_INTERVAL * 1000) - (epoch_ms % (LOOP_INTERVAL * 1000)) ))
  if (( remaining_ms < 150 )); then
    remaining_ms=$(( remaining_ms + LOOP_INTERVAL * 1000 ))
  fi
  sleep_sec=$(( remaining_ms / 1000 ))
  sleep_ms=$(( remaining_ms % 1000 ))

  sleep "${sleep_sec}.${sleep_ms}" 2>/dev/null || sleep "$sleep_sec"  # works on any modern sleep

  # ===== LED control (silent, synchronized across miners) =====
  if (( TC > CPU_HIGH || CoolSecs > 0 || LowHash5Secs > 0 || LowHash30Secs > 0 || CPUHighSec > 0 || LowMinersSec > 0 || DNSGood == 0 )); then
    set_led 0 0 0 || true                      # turn off led (error/trigger states)
    save_LED "off"
  elif (( TC > CPU_WARN )); then
    set_led "$PULSE_VAL" 0 0 || true           # red pulsing when warm
    save_LED "red"
  else
    set_led 0 "$PULSE_VAL" 0 || true           # green pulsing when healthy
    save_LED "green"
  fi

done
#########################################################
Ctrl-O, Enter, Ctrl-X



Command:   sudo systemctl daemon-reload
Command:   sudo systemctl enable proxy-watchdog.service
Command:   sudo systemctl start proxy-watchdog.service


Command:   sudo reboot  (you can reboot later)










