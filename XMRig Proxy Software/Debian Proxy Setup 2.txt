
********************  COMMON COMMANDS  ********************


Check the update log:    sudo tail -n 100 /var/log/proxy_update.log

Check the status log:    sudo tail -n 100 /var/log/proxy-status.log

Get proxy status:   source /etc/proxy.env && printf '%s\r\n' "$STATUS_TOKEN" | nc -w 2 127.0.0.1 "$STATUS_PORT"







********************  INSTALL SENSORS   ********************

Command:   sudo apt update
Command:   sudo apt install lm-sensors -y
Command:   yes | sudo sensors-detect --auto

Read Temps and Voltages:    sensors










miner-status-handler.sh is a secure, fault-tolerant telemetry script that runs each time a client connects to the miner’s status port, verifies the provided password, loads configuration from /etc/proxy.env, and then collects real-time hashrate, CPU temperature, and workers using several layered fallback methods to ensure compatibility across different XMRig versions and hardware. It intelligently probes multiple API endpoints to extract the 10-second hashrate, reads temperature from lm-sensors or system thermal files, determines power either from AMD PPT, generic sensor keys, a configured fallback value, or by calculating VRM current × voltage when necessary. Every step is logged to /var/log/miner-status.log, and regardless of errors, the script always returns a clean, machine-readable JSON object containing the miner’s current performance metrics, making it reliable for dashboards, automation tools, and your auto-update system.







********************   PROXY STATUS   ********************

Command:   sudo nano /usr/local/bin/proxy-status-handler.sh
#########################################################
#!/usr/bin/env bash
# Per-connection handler for proxy-status
# Version
# 1.00 - first version
# 1.01 - added LED status
# 1.02 - added CPU Power

LOG_ENABLED=0   #turn off logging to save space

set -euo pipefail

# ----- safety: PASSWORD must be exported by the listener -----
if [ -z "${PASSWORD:-}" ]; then
  printf '%s\r\n' '{"error":"server password not set"}'
  exit 0
fi

# ----- Load runtime configuration (prefer /etc/proxy.env) -----
[ -f /etc/proxy.env ] && . /etc/proxy.env
: "${API_HOST:=127.0.0.1}"
: "${API_PORT:=${PROXY_HTTP_PORT:-8086}}"    # XMRig-Proxy HTTP API port
: "${API_TOKEN:=${PROXY_HTTP_TOKEN:-}}"      # XMRig-Proxy HTTP token
: "${LOG:=/var/log/proxy-status.log}"

log() {
  (( LOG_ENABLED )) || return 0
  printf '%s %s\n' "$(date '+%F %T')" "$*" >>"$LOG"
}

# ----- helpers ----------------------------------------------------------

# Read hashrate (10s) from XMRig-Proxy HTTP API; returns integer in H/s (value × 1000)
read_hashrate() {
  local json h10_kh curl_rc raw_val
  log "DEBUG: read_hashrate() starting (API_HOST=${API_HOST}, API_PORT=${API_PORT}, API_TOKEN=${API_TOKEN})"

  # ----- build curl args -----
  local curl_args=(-fsS --max-time 3)
  if [ -n "${API_TOKEN:-}" ]; then
    curl_args+=(-H "Authorization: Bearer $API_TOKEN")
  fi
  log "DEBUG: curl args built: ${curl_args[*]}"

  # ----- use only /2/summary on the configured port -----
  log "DEBUG: Trying endpoint http://${API_HOST}:${API_PORT}/2/summary"

  if (( LOG_ENABLED )); then
    json=$(curl "${curl_args[@]}" "http://${API_HOST}:${API_PORT}/2/summary" 2>>"$LOG" || true); curl_rc=$?
  else
    json=$(curl "${curl_args[@]}" "http://${API_HOST}:${API_PORT}/2/summary" 2>/dev/null || true); curl_rc=$?
  fi

  if [ $curl_rc -ne 0 ]; then
    log "DEBUG: curl failed (rc=$curl_rc) for port ${API_PORT}/2/summary"
    return 1
  fi
  if [ -z "$json" ]; then
    log "DEBUG: empty response from ${API_PORT}/2/summary"
    return 1
  fi

  log "DEBUG: first 200B of response: $(printf '%s' "$json" | head -c 200)"

  # Extract the 10s total hashrate in kH/s (first element of .hashrate.total array)
  h10_kh=$(printf '%s' "$json" | jq -r '.hashrate.total[0] // empty')

  if [ -n "$h10_kh" ] && [[ "$h10_kh" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
    log "DEBUG: raw 10s hashrate (kH/s): $h10_kh"
    # Multiply by 1000 and round to nearest integer
    raw_val=$(awk "BEGIN {printf \"%d\", $h10_kh * 1000 + 0.5}")
    log "DEBUG: converted to H/s (x1000): $raw_val"
    echo "$raw_val"
    return 0
  fi

  log "DEBUG: no valid hashrate.total[0] found in /2/summary on port ${API_PORT}"
  return 1
}



# Read CPU temperature (Celsius integer)
read_cpu_temp() {
  local line val
  if command -v sensors >/dev/null 2>&1; then
    line=$(sensors 2>/dev/null | grep -m1 -E 'Tctl:|Tdie:|Package id 0:|CPU Temperature:') || true
    if [ -n "$line" ]; then
      val=$(echo "$line" | grep -oE '[0-9]+(\.[0-9]+)?' | head -n1)
      if [ -n "$val" ]; then
        printf '%s' "${val%.*}"
        return 0
      fi
    fi
  fi
  if [ -r /sys/class/thermal/thermal_zone0/temp ]; then
    awk '{printf "%d", int($1/1000)}' /sys/class/thermal/thermal_zone0/temp
    return 0
  fi
  return 1
}

# Read package/GPU power (Watts, integer) via lm-sensors
read_watts() {
  local line val sensors_out

  log "DEBUG: read_watts() start"

  # Ensure lm-sensors is available
  if ! command -v sensors >/dev/null 2>&1; then
    log "DEBUG: sensors not found, attempting install"
    apt-get update -y >>"$LOG" 2>&1 || true
    apt-get install -y lm-sensors >>"$LOG" 2>&1 || true
  fi

  if command -v sensors >/dev/null 2>&1; then
    log "DEBUG: sensors command found"

    # Capture full sensors output for debugging
    sensors_out=$(sensors 2>/dev/null)
    log "DEBUG: sensors output BEGIN"
    log "$sensors_out"
    log "DEBUG: sensors output END"

    # Try to extract power line
    line=$(printf '%s\n' "$sensors_out" | grep -m1 -E '^[[:space:]]*PPT:|^[[:space:]]*Package power:|^[[:space:]]*power1:')
    log "DEBUG: matched power line: ${line:-<none>}"

    if [ -n "$line" ]; then
      val=$(printf '%s' "$line" | grep -oE '[0-9]+(\.[0-9]+)?' | head -n1)
      log "DEBUG: extracted numeric value: ${val:-<none>}"

      if [ -n "$val" ]; then
        log "DEBUG: returning watts=${val%.*}"
        printf '%s' "${val%.*}"
        return 0
      fi
    fi
  else
    log "DEBUG: sensors still unavailable after install attempt"
  fi

  log "DEBUG: watt detection failed, returning fallback 0"
  printf '0'
  return 0
}


# Read number of connected workers (miners) from XMRig-Proxy HTTP API
read_workers() {
  local json workers

  # Build curl command with optional auth
  local curl_args=(-fsS --max-time 3)
  if [ -n "${API_TOKEN:-}" ]; then
    curl_args+=(-H "Authorization: Bearer $API_TOKEN")
  fi

  # Fetch directly from the configured host:port /2/summary
  json=$(curl "${curl_args[@]}" "http://$API_HOST:$API_PORT/2/summary" 2>/dev/null)

  # If no response, fail silently
  [ -z "$json" ] && return 1

  # Get the worker count — prefer .workers, fall back to .miners.now just in case
  workers=$(printf '%s' "$json" | jq -r '.workers // .miners.now // empty')

  # Validate it's a non-negative integer
  if [[ "$workers" =~ ^[0-9]+$ ]] && [ "$workers" -ge 0 ]; then
    printf '%s' "$workers"
    return 0
  fi

  return 1
}


# Read current LED status from watchdog file (single word: off/red/green)
read_led_status() {
  if [[ -r /var/run/led_status ]]; then
    local status
    status=$(head -n1 /var/run/led_status 2>/dev/null | tr -d '\n\r')
    case "$status" in
      off|red|green) printf '%s' "$status" ;;
      *) printf 'unknown' ;;
    esac
  else
    printf 'unknown'
  fi
}

# ----- auth + response (robust) -----
pass=""
if ! IFS= read -r -t 3 pass; then
  log "WARN: password read failed or timed out"
else
  pass=${pass%$'\r'}
fi

if [ -z "${pass}" ] || [ "$pass" != "$PASSWORD" ]; then
  printf '%s\r\n' '{"error":"invalid or missing password"}'
  exit 0
fi

# ----- get metrics safely (no echo fallbacks) -----
HR=0
if output=$(read_hashrate 2>/dev/null) && [[ "$output" =~ ^[0-9]+$ ]]; then
  HR="$output"
fi

TC=0
if output=$(read_cpu_temp 2>/dev/null) && [[ "$output" =~ ^[0-9]+$ ]]; then
  TC="$output"
fi

WT=0
if output=$(read_watts 2>/dev/null) && [[ "$output" =~ ^[0-9]+$ ]]; then
  WT="$output"
fi

WK=0
if output=$(read_workers 2>/dev/null) && [[ "$output" =~ ^[0-9]+$ ]] && [ "$output" -gt 0 ]; then
  WK="$output"
fi

LS=$(read_led_status)
log "RESULT: hashrate=$HR temp=$TC watts=$WT workers=$WK led=$LS"
printf '{"hashrate":%s,"temp":%s,"watts":%s,"workers":%s,"led":"%s"}\r\n' "$HR" "$TC" "$WT" "$WK" "$LS"
#########################################################
Ctrl-O, Enter, Ctrl-X



Command:   sudo chmod +x /usr/local/bin/proxy-status-handler.sh





Command:   sudo nano /usr/local/bin/proxy-status.sh
#########################################################
#!/usr/bin/env bash
# proxy-status.sh — tiny TCP JSON server (socat-based)
set -euo pipefail
[ -f /etc/proxy.env ] && . /etc/proxy.env  

# Only export the TCP server password; handler loads the rest from /etc/proxy.env
export PASSWORD="${STATUS_TOKEN}"   # from /etc/proxy.env
PORT="${STATUS_PORT}"                 # from /etc/proxy.env

echo "proxy-status listening on :$PORT (password required)" >&2

# -T 5: I/O timeout; fork: one process per client; -d -d -v: verbose logs
exec socat -d -d -v -T 5 \
  TCP-LISTEN:"$PORT",reuseaddr,fork \
  EXEC:'/usr/local/bin/proxy-status-handler.sh',stderr
#########################################################
Ctrl-O, Enter, Ctrl-X



Command:   sudo chmod +x /usr/local/bin/proxy-status.sh

Command:   sudo chmod 755 /usr/local/bin/proxy-status.sh

Command:   sudo apt update
Command:   sudo apt install -y socat netcat-openbsd
Command:   sudo apt install -y curl


Command:   sudo nano /etc/systemd/system/proxy-status.service
#########################################################
[Unit]
Description=Proxy Status JSON Server
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/local/bin/proxy-status.sh
Restart=always
RestartSec=2
User=root
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
#########################################################
Ctrl-O Enter Ctrl-X




Command:   sudo chmod 644 /etc/systemd/system/proxy-status.service

Command:   sudo systemctl daemon-reload
Command:   sudo systemctl enable --now proxy-status.service
  

Command:   sudo reboot

Test the script on the same machine:   source /etc/proxy.env && printf '%s\r\n' "$STATUS_TOKEN" | nc -w 2 127.0.0.1 "$STATUS_PORT"

If it doesn't work:   sudo journalctl -u proxy-status -f
If it still doesn't work, run all the steps above on this page again.
If it still doesn't work, give the source and log to AI:   sudo tail -f /var/log/proxy-status.log  

Correct Result:    {"hashrate":109500,"temp":38,"workers":8,"led":"green"}



Powershell test the script on windows:   echo jjasfSGB122$@ | ncat 192.168.1.35 8080
    Powershell install ncat command:   winget install Nmap
   






















This XMRig auto-update script is a fully automated maintenance system that checks GitHub for the newest XMRig release, compares it to the miner’s local version, gathers real-time performance metrics, identifies motherboard firmware, and then—if an update is available—stops the miner, pulls the latest tag, rebuilds XMRig from source, validates the build, restarts the service, and measures post-update hashrate, temperature, and wattage. Whether or not XMRig itself updates, the script also performs a complete Debian system upgrade, sends a detailed email report (with performance before/after, firmware info, and the latest 200 log lines), delays emails based on hostname to prevent inbox flooding, and finally reboots the system to apply updates. All actions are logged to /var/log/xmrig_update.log, and the script uses your miner-status TCP server to reliably fetch live metrics, making each miner self-updating, self-monitoring, and fully autonomous.






********************  PROXY AUTO UPDATE   ********************

Command:   sudo nano /usr/local/bin/proxy-auto-update.sh
#########################################################
#!/bin/bash
#Version 1.0
# proxy-auto-update (root)
# Logs: /var/log/proxy_update.log
# Uses: /usr/local/bin/send_email.sh (provides send_email(subject, body))

set -o pipefail

REPO_DIR="/root/xmrig-proxy"
BUILD_DIR="$REPO_DIR/build"
BIN="$BUILD_DIR/xmrig-proxy"
LOG="/var/log/proxy_update.log"
GITHUB_API="https://api.github.com/repos/xmrig/xmrig-proxy/releases/latest"

HOSTNAME_STR="$(hostname)"    # Store hostname to speed up processing

if [ ! -f /etc/proxy.env ]; then
  echo "ERROR: Required configuration file /etc/proxy.env not found!" >&2
  exit 1
fi
. /etc/proxy.env

# ---- proxy-status TCP JSON server (your socat listener) ----------------------
PROXY_HOST="127.0.0.1"
# STATUS_PORT     from /etc/proxy.env
# STATUS_TOKEN    from /etc/proxy.env

# --- Load reusable email function --------------------------------------------
SEND_EMAIL_LIB="/usr/local/bin/send_email.sh"
if [ -r "$SEND_EMAIL_LIB" ]; then
  # shellcheck source=/usr/local/bin/send_email.sh
  source "$SEND_EMAIL_LIB"
else
  send_email() { echo "[WARN] send_email.sh not found; would have sent: $1"; }
fi

ts() { date '+%Y-%m-%d %H:%M:%S'; }
log() {
  local line="[$(ts)] $*"
  if [ -w "$LOG" ] || touch "$LOG" 2>/dev/null; then
    echo "$line" | tee -a "$LOG"
  else
    echo "$line"
  fi
}

# ---- Get Motherboard Firmware (BIOS/UEFI) ------------------------------------
get_motherboard_firmware() {
  local firmware="Unknown" raw_name="Unknown" manufacturer="Unknown" display_name="Unknown"

  # ── Ensure dmidecode exists and run as root ──
  if ! command -v dmidecode >/dev/null 2>&1; then
    if command -v apt >/dev/null 2>&1; then
      sudo apt update -y >>"$LOG" 2>&1
      sudo apt install -y dmidecode >>"$LOG" 2>&1 || true
    fi
  fi

  if command -v dmidecode >/dev/null 2>&1; then
    firmware=$(sudo dmidecode -s bios-version 2>/dev/null | head -n1)
    raw_name=$(sudo dmidecode -s baseboard-product-name 2>/dev/null | head -n1)
    manufacturer=$(sudo dmidecode -s baseboard-manufacturer 2>/dev/null | head -n1)

    # Try system fields if baseboard is generic
    if [[ "$raw_name" == "Default string" || -z "$raw_name" ]]; then
      raw_name=$(sudo dmidecode -s system-product-name 2>/dev/null | head -n1)
      manufacturer=$(sudo dmidecode -s system-manufacturer 2>/dev/null | head -n1)
    fi
  fi

  raw_name="${raw_name:-Unknown}"
  manufacturer="${manufacturer:-Unknown}"
  raw_name="${raw_name%% *}"      # strip everything after first space
  manufacturer="${manufacturer%% *}"

  # ── ONE giant case statement to rule them all ──
  case "$raw_name" in
    DRFXL|DRFXL*) display_name="BD795i SE" ;;
    B75|B75-*) display_name="Biostar TB75" ;;
    TB85|TB85-*) display_name="Biostar TB85" ;;
    TB250-BTC|TB250-BTC*) display_name="Biostar TB250-BTC" ;;
    TB360-BTC|TB360-BTC*) display_name="Biostar TB360-BTC" ;;
    B250|B250-*) display_name="ASUS / MSI Mining Expert" ;;
    # ASUS ROG / Prime
    "ROG CROSSHAIR VII HERO"|"CROSSHAIR VII HERO"* ) display_name="ASUS ROG Crosshair VII Hero" ;;
    "ROG CROSSHAIR VIII"* ) display_name="ASUS ROG Crosshair VIII $raw_name" ;;
    "ROG STRIX"* ) display_name="ASUS ROG Strix $raw_name" ;;
    "PRIME X570"*|"PRIME B550"* ) display_name="ASUS Prime $raw_name" ;;
    # MSI
    "MEG X570"*"ACE"*|"MEG X570"*"UNIFY"* ) display_name="MSI MEG X570 $raw_name" ;;
    "MPG X570"*|"MPG B550"* ) display_name="MSI MPG $raw_name" ;;
    "B550"*|"X570"* ) display_name="MSI $raw_name" ;;
    # Gigabyte Aorus
    "X570 AORUS"*) display_name="Gigabyte X570 Aorus $raw_name" ;;
    "B550 AORUS"*) display_name="Gigabyte B550 Aorus $raw_name" ;;
    # ASRock
    "X570 Taichi"|"X570 Phantom"*) display_name="ASRock $raw_name" ;;
    # Generic/OEM fallback: use MOTHERBOARD_NAME from /etc/proxy.env
    "Default string"|"Default"|"Unknown"|"" )
      display_name="${MOTHERBOARD_NAME:-Generic Mini PC}"
      ;;
    # Normal branded boards
    *) 
      if [[ "$manufacturer" != "Unknown" && "$raw_name" != "Unknown" ]]; then
        display_name="$manufacturer $raw_name"
      else
        display_name="${MOTHERBOARD_NAME:-Generic Mini PC}"
      fi
      ;;
  esac

  # ── Export ──
  MB_FIRMWARE="${firmware:-Unknown}"
  MB_NAME="$display_name"
  MB_RAW_NAME="${raw_name:-Unknown}"
  MB_MANUFACTURER="${manufacturer:-Unknown}"
  log "Motherboard: $MB_NAME | Firmware: $MB_FIRMWARE"
}

# ---- Metrics via miner-status ------------------------------------------------
# Ensures jq exists, calls the TCP endpoint once, and fills globals:
# HR_NOW TEMP_NOW WORKERS_NOW (integers; 0 on failure)
get_metrics_now() {
  local json hr tc wk
  # jq (quiet install if missing)
  if ! command -v jq >/dev/null 2>&1; then
    log "Installing jq for JSON parsing..."
    apt update -y >>"$LOG" 2>&1 && apt install -y jq >>"$LOG" 2>&1 || true
  fi
  # netcat variants differ; try GNU -w/-q combo if available
  if printf '%s\r\n' "$STATUS_TOKEN" | nc -h 2>&1 | grep -q -- '-q '; then
    json=$(printf '%s\r\n' "$STATUS_TOKEN" | nc -w 3 -q 1 "$PROXY_HOST" "$STATUS_PORT" 2>>"$LOG" || true)
  else
    json=$(printf '%s\r\n' "$STATUS_TOKEN" | nc -w 3 "$PROXY_HOST" "$STATUS_PORT" 2>>"$LOG" || true)
  fi
  if [ -z "$json" ]; then
    log "NOTICE: miner-status returned empty response"
    HR_NOW=0; TEMP_NOW=0; WORKERS_NOW=0
    return 1
  fi
  # Parse integers; enforce numeric, default to 0 on null/missing
  hr=$(printf '%s' "$json" | jq -r '.hashrate // 0' 2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  tc=$(printf '%s' "$json" | jq -r '.temp // 0' 2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  wk=$(printf '%s' "$json" | jq -r '.workers // 0' 2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  [[ "$hr" =~ ^[0-9]+$ ]] || hr=0
  [[ "$tc" =~ ^[0-9]+$ ]] || tc=0
  [[ "$wk" =~ ^[0-9]+$ ]] || wk=0
  HR_NOW="$hr"
  TEMP_NOW="$tc"
  WORKERS_NOW="$wk"
  return 0
}

# Same, but fills HR_AFTER/TEMP_AFTER/WORKERS_AFTER
get_metrics_after() {
  local json hr tc wk
  if ! command -v jq >/dev/null 2>&1; then
    apt update -y >>"$LOG" 2>&1 && apt install -y jq >>"$LOG" 2>&1 || true
  fi
  if printf '%s\r\n' "$STATUS_TOKEN" | nc -h 2>&1 | grep -q -- '-q '; then
    json=$(printf '%s\r\n' "$STATUS_TOKEN" | nc -w 3 -q 1 "$PROXY_HOST" "$STATUS_PORT" 2>>"$LOG" || true)
  else
    json=$(printf '%s\r\n' "$STATUS_TOKEN" | nc -w 3 "$PROXY_HOST" "$STATUS_PORT" 2>>"$LOG" || true)
  fi
  hr=$(printf '%s' "$json" | jq -r '.hashrate // 0' 2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  tc=$(printf '%s' "$json" | jq -r '.temp // 0' 2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  wk=$(printf '%s' "$json" | jq -r '.workers // 0' 2>>"$LOG" | awk 'NF{printf "%.0f",$1}')
  [[ "$hr" =~ ^[0-9]+$ ]] || hr=0
  [[ "$tc" =~ ^[0-9]+$ ]] || tc=0
  [[ "$wk" =~ ^[0-9]+$ ]] || wk=0
  HR_AFTER="$hr"
  TEMP_AFTER="$tc"
  WORKERS_AFTER="$wk"
}

perform_system_update() {
  log "Waiting 1 minute before system upgrade..."
  sleep 60

  log "Stopping xmrig-proxy before system upgrade..."
  systemctl stop xmrig-proxy >>"$LOG" 2>&1 || true

  log "Running full Debian system upgrade..."
  export DEBIAN_FRONTEND=noninteractive
  apt-get update >>"$LOG" 2>&1
  apt-get -y -o Dpkg::Options::=--force-confdef -o Dpkg::Options::=--force-confold full-upgrade >>"$LOG" 2>&1
  apt-get -y autoremove >>"$LOG" 2>&1 || true
}

# ---- Begin -------------------------------------------------------------------
log "Starting XMRig-Proxy Auto Update..."
log "==============================="
log "Checking for XMRig-Proxy updates..."

if ! command -v curl >/dev/null 2>&1; then
  log "Installing curl..."
  apt update -y >>"$LOG" 2>&1 && apt install -y curl >>"$LOG" 2>&1
fi

# Local version
LOCAL_VER=""
if [ -x "$BIN" ]; then
  LOCAL_VER=$("$BIN" --version 2>/dev/null | head -n1 | grep -oE '[0-9]+(\.[0-9]+)*')
fi
if [ -z "$LOCAL_VER" ]; then
  cd "$REPO_DIR" 2>/dev/null || { log "ERROR: cannot cd $REPO_DIR"; exit 1; }
  LOCAL_VER=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//')
fi
[ -z "$LOCAL_VER" ] && LOCAL_VER="(unknown)"

get_metrics_now || true
get_motherboard_firmware

# Latest version
LATEST_VER=$(curl -s "$GITHUB_API" | grep -oP '"tag_name":\s*"\Kv?[0-9.]+' | sed 's/^v//')
if [ -z "$LATEST_VER" ]; then
  log "ERROR: Failed to fetch latest version from GitHub."
  perform_system_update

  EMAIL_SUBJECT="$HOSTNAME_STR XMRig-Proxy Check Error"
  log "Sending email: $EMAIL_SUBJECT"
  log "Rebooting after email is sent to apply updates."

  send_email "$EMAIL_SUBJECT" "[$(ts)] Could not fetch latest version.
See $LOG"
  log "Rebooting to apply updates..."
  /sbin/reboot
  exit 0
fi

log "Local : $LOCAL_VER | HR: ${HR_NOW:-0} H/s | Temp: ${TEMP_NOW:-0} C | Workers: ${WORKERS_NOW:-0}"
log "Latest: $LATEST_VER"

# Already current
if [ "$LOCAL_VER" = "$LATEST_VER" ]; then
  log "Already up to date."

  perform_system_update

  EMAIL_SUBJECT="$HOSTNAME_STR XMRig-Proxy Current V$LOCAL_VER ${HR_NOW:-0} H/s ${TEMP_NOW:-0}C ${WORKERS_NOW:-0} Workers"
  log "Sending email: $EMAIL_SUBJECT"
  log "Rebooting after email is sent to apply updates."

  BODY="Host: $HOSTNAME_STR
When: $(ts)
Status: XMRig-Proxy is current.
Local version:  $LOCAL_VER
Latest version: $LATEST_VER
Hashrate (now): ${HR_NOW:-0} H/s
CPU Temp:       ${TEMP_NOW:-0} C
Workers:        ${WORKERS_NOW:-0}
Motherboard:    $MB_NAME
Motherboard Firmware: $MB_FIRMWARE

=====================================
 Last 200 lines of proxy_update.log
=====================================
$(awk 'index($0,"Starting Proxy Auto Update"){last=NR} {lines[NR]=$0} END{start=last?last:(NR-199); if(start<1) start=1; for(i=start;i<=NR;i++) print lines[i] }' "$LOG" 2>/dev/null | tail -n 200)"

  send_email "$EMAIL_SUBJECT" "$BODY"
  log "Rebooting to apply updates..."
  /sbin/reboot
  exit 0
fi

# ----- Update -----
log "Update available. Stopping service..."
systemctl stop xmrig-proxy >>"$LOG" 2>&1

cd "$REPO_DIR" || { log "ERROR: cannot cd $REPO_DIR"; exit 1; }
log "Fetching tags..."
git fetch --all --tags >>"$LOG" 2>&1
log "Checking out v$LATEST_VER..."
git checkout "v$LATEST_VER" >>"$LOG" 2>&1 || git checkout "$LATEST_VER" >>"$LOG" 2>&1

log "Building..."
mkdir -p "$BUILD_DIR"
cd "$BUILD_DIR" || { log "ERROR: cannot cd $BUILD_DIR"; exit 1; }
cmake .. >>"$LOG" 2>&1 && make -j"$(nproc)" >>"$LOG" 2>&1

if [ ! -x "$BIN" ]; then
  log "ERROR: XMRig-Proxy binary not built: $BIN missing"
  send_email "$HOSTNAME_STR XMRig-Proxy Build FAILED" "make succeeded but $BIN not executable.\n\n$(tail -50 "$LOG")"
  exit 1
fi
if ! "$BIN" --version 2>/dev/null | grep -q "$LATEST_VER"; then
  log "ERROR: Version mismatch after build. Expected $LATEST_VER"
  send_email "$HOSTNAME_STR XMRig-Proxy Build FAILED" "Built binary does not report version $LATEST_VER.\n\n$("$BIN" --version 2>&1 || echo 'No version')\n\n$(tail -50 "$LOG")"
  exit 1
fi

log "Restarting xmrig-proxy..."
systemctl restart xmrig-proxy >>"$LOG" 2>&1
log "Update complete."

log "Waiting 5 minutes for new hashrate to stabilize..."
sleep 300

NEW_VER=$("$BIN" --version 2>/dev/null | head -n1 | grep -oE '[0-9]+(\.[0-9]+)*')
[ -z "$NEW_VER" ] && NEW_VER="$LATEST_VER"

get_metrics_after || true
log "Now running: $NEW_VER | HR: ${HR_AFTER:-0} H/s | Temp: ${TEMP_AFTER:-0} C | Workers: ${WORKERS_AFTER:-0}"
perform_system_update

EMAIL_SUBJECT="$HOSTNAME_STR Updated to V$NEW_VER ${HR_AFTER:-0} H/s ${TEMP_AFTER:-0}C ${WORKERS_AFTER:-0} Workers"
log "Sending email: $EMAIL_SUBJECT"
log "Rebooting after email is sent to apply updates."

BODY="Host: $HOSTNAME_STR
When: $(ts)
Action: XMRig-Proxy auto-update applied
From: $LOCAL_VER
To:   $NEW_VER
Hashrate (before/after): ${HR_NOW:-0} / ${HR_AFTER:-0} H/s
CPU Temp (before/after): ${TEMP_NOW:-0} / ${TEMP_AFTER:-0} C
Workers (before/after):  ${WORKERS_NOW:-0} / ${WORKERS_AFTER:-0}
Motherboard:             $MB_NAME
Motherboard Firmware:    $MB_FIRMWARE
Service: xmrig-proxy.service (restarted)


=====================================
 Last 200 lines of proxy_update.log
=====================================
$(awk 'index($0,"Starting Proxy Auto Update"){last=NR} {lines[NR]=$0} END{start=last?last:(NR-199); if(start<1) start=1; for(i=start;i<=NR;i++) print lines[i] }' "$LOG" 2>/dev/null | tail -n 200)"

send_email "$EMAIL_SUBJECT" "$BODY"
log "Rebooting to apply updates..."
/sbin/reboot
exit 0
#########################################################
Ctrl-O, Enter, Ctrl-X




Command:   sudo chmod +x /usr/local/bin/proxy-auto-update.sh

Command:   sudo crontab -e
Choose:  1
Add this to the bottom:     57 1 * * 0 /usr/local/bin/proxy-auto-update.sh

Test it manually:    sudo /usr/local/bin/proxy-auto-update.sh

	System will auto reboot after 1 minute if it works

Check the log:    sudo tail -n 30 /var/log/proxy_update.log 






